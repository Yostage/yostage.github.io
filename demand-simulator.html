<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Demand Capacity Simulation</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      background: linear-gradient(135deg, #0a0a0f 0%, #12121a 50%, #0d0d14 100%);
      color: #e8e8ed;
      min-height: 100vh;
    }
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      border-radius: 2px;
      cursor: pointer;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "recharts": "https://esm.sh/recharts@2.10.3?deps=react@18.2.0,react-dom@18.2.0"
    }
  }
  </script>

  <script type="module">
    import React, { useState, useMemo } from 'react';
    import { createRoot } from 'react-dom/client';
    import { AreaChart, Area, XAxis, YAxis, ReferenceLine, ResponsiveContainer, Tooltip } from 'recharts';

    const e = React.createElement;

    // Gaussian function for bell curve
    const gaussian = (x, mean, stdDev) => {
      const exponent = -0.5 * Math.pow((x - mean) / stdDev, 2);
      return Math.exp(exponent);
    };

    function DemandCapacityViz() {
      // Read initial values from URL
      const getInitialParams = () => {
        const params = new URLSearchParams(window.location.search);
        const machines = Number(params.get('machines')) || 100;
        const queueTimeout = Number(params.get('queueTimeout')) || 30;

        // Try to parse curves array from URL, fallback to single curve for backward compatibility
        const curvesParam = params.get('curves');
        let curves;
        if (curvesParam) {
          try {
            curves = JSON.parse(decodeURIComponent(curvesParam));
          } catch (e) {
            curves = null;
          }
        }

        // Backward compatibility: if no curves param, build from old params
        if (!curves) {
          curves = [{
            id: 'curve-1',
            type: params.get('type') || 'gaussian',
            peakHour: Number(params.get('peakHour')) || 15,
            curveWidth: Number(params.get('curveWidth')) || 3,
            totalDemand: Number(params.get('totalDemand')) || 50000,
            priority: 1,
            color: '#818cf8'
          }];
        }

        return { machines, queueTimeout, curves };
      };

      const initial = getInitialParams();
      const [machines, setMachines] = useState(initial.machines);
      const [queueTimeout, setQueueTimeout] = useState(initial.queueTimeout);
      const [curves, setCurves] = useState(initial.curves);

      // Helper to update a specific curve
      const updateCurve = (index, updates) => {
        const newCurves = [...curves];
        newCurves[index] = { ...newCurves[index], ...updates };
        setCurves(newCurves);
      };

      // Helper to add a new curve
      const addCurve = () => {
        if (curves.length >= 3) return;
        const colors = ['#818cf8', '#a78bfa', '#c084fc'];
        const newCurve = {
          id: `curve-${Date.now()}`,
          type: 'gaussian',
          peakHour: 15,
          curveWidth: 3,
          totalDemand: 50000,
          priority: curves.length + 1,
          color: colors[curves.length] || '#818cf8'
        };
        setCurves([...curves, newCurve]);
      };

      // Helper to remove a curve
      const removeCurve = (index) => {
        if (curves.length <= 1) return;
        setCurves(curves.filter((_, i) => i !== index));
      };

      // Update URL when parameters change
      React.useEffect(() => {
        const params = new URLSearchParams();
        params.set('machines', machines);
        params.set('queueTimeout', queueTimeout);
        params.set('curves', encodeURIComponent(JSON.stringify(curves)));
        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState({}, '', newUrl);
      }, [machines, curves, queueTimeout]);

      const { data, metrics } = useMemo(() => {
        const points = [];

        // Generate demand arrays for each curve
        const demandByCurve = {};
        curves.forEach(curve => {
          let getDemand;
          if (curve.type === 'linear') {
            const constantDemand = curve.totalDemand / 1440;
            getDemand = () => constantDemand;
          } else {
            // Gaussian
            const stdDevMinutes = curve.curveWidth * 60;
            const peakMinute = curve.peakHour * 60;
            const gaussianIntegral = stdDevMinutes * Math.sqrt(2 * Math.PI);
            const scaleFactor = curve.totalDemand / gaussianIntegral;
            getDemand = (minute) => scaleFactor * gaussian(minute, peakMinute, stdDevMinutes);
          }

          // Generate 1440-minute demand array for this curve
          demandByCurve[curve.id] = Array.from({ length: 1440 }, (_, minute) => getDemand(minute));
        });

        let totalUtilization = 0;
        const demandValues = [];

        // Per-curve queues: {curveId: [{arrivalTime, demand, curveId}]}
        const queuesByCurve = {};
        const utilizationByCurve = {};
        const shedByCurve = {};
        const usageValuesByCurve = {};

        curves.forEach(curve => {
          queuesByCurve[curve.id] = [];
          utilizationByCurve[curve.id] = 0;
          shedByCurve[curve.id] = 0;
          usageValuesByCurve[curve.id] = [];
        });
        let totalShedDemand = 0;

        for (let minute = 0; minute < 1440; minute++) {
          const hour = minute / 60;

          // Sum demand across all curves for this minute
          const demand = curves.reduce((sum, curve) => sum + demandByCurve[curve.id][minute], 0);

          // Step 1: Remove timed-out requests from all queues
          let shedThisMinute = 0;
          curves.forEach(curve => {
            const queue = queuesByCurve[curve.id];
            for (let i = queue.length - 1; i >= 0; i--) {
              if (minute - queue[i].arrivalTime > queueTimeout) {
                const shedAmount = queue[i].demand;
                shedThisMinute += shedAmount;
                totalShedDemand += shedAmount;
                shedByCurve[curve.id] += shedAmount; // Track per-curve shed
                queue.splice(i, 1);
              }
            }
          });

          // Step 2 & 3 & 4: Priority-based processing
          // Sort curves by priority (1 = highest priority first)
          const sortedCurves = [...curves].sort((a, b) => a.priority - b.priority);

          let availableCapacity = machines;
          let actualUsage = 0;

          // Process each priority level in order
          sortedCurves.forEach(curve => {
            let curveUsageThisMinute = 0;

            // Step 2a: Serve new demand from this curve
            const curveDemand = demandByCurve[curve.id][minute];
            const immediatelyServed = Math.min(curveDemand, availableCapacity);
            availableCapacity -= immediatelyServed;
            actualUsage += immediatelyServed;
            curveUsageThisMinute += immediatelyServed;

            // Step 2b: Queue excess demand for this curve
            const excessDemand = curveDemand - immediatelyServed;
            if (excessDemand > 0) {
              queuesByCurve[curve.id].push({
                arrivalTime: minute,
                demand: excessDemand,
                curveId: curve.id,
                priority: curve.priority
              });
            }

            // Step 3: Process queued requests for this curve (FIFO within same priority)
            // Sort queue by arrival time to maintain FIFO
            queuesByCurve[curve.id].sort((a, b) => a.arrivalTime - b.arrivalTime);

            const queue = queuesByCurve[curve.id];
            for (let i = 0; i < queue.length && availableCapacity > 0; i++) {
              const item = queue[i];
              const servedFromQueue = Math.min(item.demand, availableCapacity);
              actualUsage += servedFromQueue;
              availableCapacity -= servedFromQueue;
              curveUsageThisMinute += servedFromQueue;
              item.demand -= servedFromQueue;
            }

            // Remove fully served items from queue
            queuesByCurve[curve.id] = queuesByCurve[curve.id].filter(item => item.demand > 0);

            // Track per-curve utilization
            utilizationByCurve[curve.id] += curveUsageThisMinute;
            usageValuesByCurve[curve.id].push({ minute, usage: curveUsageThisMinute });
          });

          totalUtilization += actualUsage;

          // Calculate total queued demand across all curves
          const queueSize = curves.reduce((sum, curve) => {
            return sum + queuesByCurve[curve.id].reduce((qSum, item) => qSum + item.demand, 0);
          }, 0);

          demandValues.push({ minute, demand, usage: actualUsage, queueSize, shed: shedThisMinute });

          if (minute % 5 === 0) {
            const point = {
              time: `${Math.floor(hour).toString().padStart(2, "0")}:${(minute % 60).toString().padStart(2, "0")}`,
              hour,
              inputDemand: demand,
              actualUtilization: actualUsage,
              capacity: machines,
              queuedDemand: queueSize,
              shedDemand: shedThisMinute,
            };

            // Add per-curve demands
            curves.forEach(curve => {
              point[`demand_${curve.id}`] = demandByCurve[curve.id][minute];
            });

            points.push(point);
          }
        }

        // Step 5: At end of day, shed any remaining queued demand from all curves
        curves.forEach(curve => {
          queuesByCurve[curve.id].forEach(item => {
            const shedAmount = item.demand;
            totalShedDemand += shedAmount;
            shedByCurve[curve.id] += shedAmount;
          });
        });

        const sortedDemand = [...demandValues].sort((a, b) => b.usage - a.usage);
        const top180 = sortedDemand.slice(0, 180);
        const peakUtilization = top180.reduce((sum, d) => sum + d.usage, 0) / 180;
        const avgUtilization = totalUtilization / 1440;

        // Calculate aggregate total demand across all curves
        const aggregateTotalDemand = curves.reduce((sum, curve) => sum + curve.totalDemand, 0);

        // Calculate per-curve metrics
        const metricsByCurve = {};
        curves.forEach(curve => {
          const curveUsageValues = usageValuesByCurve[curve.id];
          const sortedCurveUsage = [...curveUsageValues].sort((a, b) => b.usage - a.usage);
          const top180Curve = sortedCurveUsage.slice(0, 180);
          const peakCurveUtilization = top180Curve.reduce((sum, d) => sum + d.usage, 0) / 180;
          const avgCurveUtilization = utilizationByCurve[curve.id] / 1440;

          metricsByCurve[curve.id] = {
            totalUtilization: Math.round(utilizationByCurve[curve.id]),
            peakUtilization: peakCurveUtilization.toFixed(1),
            avgUtilization: avgCurveUtilization.toFixed(1),
            shedDemand: Math.round(shedByCurve[curve.id]),
            shedPercent: ((shedByCurve[curve.id] / curve.totalDemand) * 100).toFixed(1),
          };
        });

        return {
          data: points,
          metrics: {
            totalUtilization: Math.round(totalUtilization),
            peakUtilization: peakUtilization.toFixed(1),
            avgUtilization: avgUtilization.toFixed(1),
            peakPercent: ((peakUtilization / machines) * 100).toFixed(1),
            avgPercent: ((avgUtilization / machines) * 100).toFixed(1),
            shedDemand: Math.round(totalShedDemand),
            shedPercent: ((totalShedDemand / aggregateTotalDemand) * 100).toFixed(1),
            byCurve: metricsByCurve,
          },
        };
      }, [machines, curves, queueTimeout]);

      const maxDemand = Math.max(...data.map((d) => d.inputDemand));
      const yMax = Math.max(machines * 1.1, maxDemand * 1.1);

      return e('div', { style: { minHeight: "100vh", padding: "32px" } },
        // Header
        e('div', { style: { marginBottom: "40px" } },
          e('h1', { style: { fontSize: "14px", fontWeight: 400, letterSpacing: "4px", textTransform: "uppercase", color: "#6b6b7b", marginBottom: "8px" } }, "Capacity Planning"),
          e('h2', { style: { fontSize: "32px", fontWeight: 300, letterSpacing: "-0.5px", margin: 0, background: "linear-gradient(90deg, #fff 0%, #a8a8b8 100%)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent" } }, "Demand Simulation")
        ),

        e('div', { style: { display: "grid", gridTemplateColumns: "320px 1fr", gap: "40px" } },
          // Controls Panel
          e('div', { style: { background: "rgba(255,255,255,0.02)", border: "1px solid rgba(255,255,255,0.06)", borderRadius: "12px", padding: "28px" } },
            e('h3', { style: { fontSize: "11px", fontWeight: 500, letterSpacing: "2px", textTransform: "uppercase", color: "#5a5a6a", marginBottom: "24px" } }, "Parameters"),

            // Machines Slider
            e('div', { style: { marginBottom: "28px" } },
              e('div', { style: { display: "flex", justifyContent: "space-between", marginBottom: "12px" } },
                e('label', { style: { fontSize: "13px", color: "#9a9aaa" } }, "Machines"),
                e('div', { style: { textAlign: "right" } },
                  e('span', { style: { fontSize: "15px", fontWeight: 600, color: "#fff" } }, machines),
                  e('span', { style: { fontSize: "11px", color: "#6b6b7b", marginLeft: "8px" } }, "(" + (machines * 1440 / 1000).toFixed(0) + "k cidu-min)")
                )
              ),
              e('input', { type: "range", min: 10, max: 500, value: machines, onChange: (ev) => setMachines(Number(ev.target.value)), style: { background: "linear-gradient(90deg, #3b82f6 0%, #1d4ed8 100%)" } })
            ),

            // Queue Timeout Slider
            e('div', { style: { marginBottom: "32px" } },
              e('div', { style: { display: "flex", justifyContent: "space-between", marginBottom: "12px" } },
                e('label', { style: { fontSize: "13px", color: "#9a9aaa" } }, "Queue Timeout"),
                e('span', { style: { fontSize: "15px", fontWeight: 600, color: "#fff" } },
                  queueTimeout >= 60 ? (queueTimeout / 60).toFixed(1) + "h" : queueTimeout + "min"
                )
              ),
              e('input', { type: "range", min: 15, max: 720, step: 15, value: queueTimeout, onChange: (ev) => setQueueTimeout(Number(ev.target.value)), style: { background: "linear-gradient(90deg, #f59e0b 0%, #d97706 100%)" } })
            ),

            // Demand Curves Section
            e('div', { style: { borderTop: "1px solid rgba(255,255,255,0.06)", paddingTop: "24px", marginBottom: "24px" } },
              e('h3', { style: { fontSize: "11px", fontWeight: 500, letterSpacing: "2px", textTransform: "uppercase", color: "#5a5a6a", marginBottom: "20px" } }, "Demand Curves"),

              // Render each curve
              ...curves.map((curveItem, index) =>
                e('div', {
                  key: curveItem.id,
                  style: {
                    marginBottom: "20px",
                    padding: "20px",
                    background: "rgba(255,255,255,0.03)",
                    border: `1px solid ${curveItem.color}33`,
                    borderRadius: "8px"
                  }
                },
                  // Curve header with remove button
                  e('div', { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "16px" } },
                    e('div', { style: { display: "flex", alignItems: "center", gap: "8px" } },
                      e('h4', { style: { fontSize: "13px", fontWeight: 600, color: curveItem.color, margin: 0 } }, `Curve ${index + 1}`),
                      e('span', {
                        style: {
                          fontSize: "10px",
                          fontWeight: 600,
                          padding: "2px 6px",
                          borderRadius: "3px",
                          background: `${curveItem.color}33`,
                          color: curveItem.color,
                          border: `1px solid ${curveItem.color}66`
                        }
                      }, `P${curveItem.priority}`)
                    ),
                    curves.length > 1 && e('button', {
                      onClick: () => removeCurve(index),
                      style: {
                        padding: "4px 10px",
                        fontSize: "11px",
                        color: "#ef4444",
                        background: "rgba(239,68,68,0.1)",
                        border: "1px solid rgba(239,68,68,0.2)",
                        borderRadius: "4px",
                        cursor: "pointer"
                      }
                    }, "Remove")
                  ),

                  // Demand Type Selector
                  e('div', { style: { marginBottom: "16px" } },
                    e('div', { style: { marginBottom: "8px" } },
                      e('label', { style: { fontSize: "12px", color: "#9a9aaa" } }, "Type")
                    ),
                    e('div', { style: { display: "flex", gap: "6px" } },
                      e('button', {
                        onClick: () => updateCurve(index, {type: 'gaussian'}),
                        style: {
                          flex: 1,
                          padding: "8px",
                          borderRadius: "4px",
                          border: curveItem.type === 'gaussian' ? `2px solid ${curveItem.color}` : "1px solid rgba(255,255,255,0.1)",
                          background: curveItem.type === 'gaussian' ? `${curveItem.color}33` : "rgba(255,255,255,0.05)",
                          color: curveItem.type === 'gaussian' ? curveItem.color : "#9a9aaa",
                          cursor: "pointer",
                          fontSize: "12px",
                          fontWeight: curveItem.type === 'gaussian' ? 600 : 400
                        }
                      }, "Gaussian"),
                      e('button', {
                        onClick: () => updateCurve(index, {type: 'linear'}),
                        style: {
                          flex: 1,
                          padding: "8px",
                          borderRadius: "4px",
                          border: curveItem.type === 'linear' ? `2px solid ${curveItem.color}` : "1px solid rgba(255,255,255,0.1)",
                          background: curveItem.type === 'linear' ? `${curveItem.color}33` : "rgba(255,255,255,0.05)",
                          color: curveItem.type === 'linear' ? curveItem.color : "#9a9aaa",
                          cursor: "pointer",
                          fontSize: "12px",
                          fontWeight: curveItem.type === 'linear' ? 600 : 400
                        }
                      }, "Linear")
                    )
                  ),

                  // Priority Selector
                  e('div', { style: { marginBottom: "16px" } },
                    e('div', { style: { marginBottom: "8px" } },
                      e('label', { style: { fontSize: "12px", color: "#9a9aaa" } }, "Priority")
                    ),
                    e('div', { style: { display: "flex", gap: "6px" } },
                      [1, 2, 3].map(p =>
                        e('button', {
                          key: p,
                          onClick: () => updateCurve(index, {priority: p}),
                          style: {
                            flex: 1,
                            padding: "8px",
                            borderRadius: "4px",
                            border: curveItem.priority === p ? `2px solid ${curveItem.color}` : "1px solid rgba(255,255,255,0.1)",
                            background: curveItem.priority === p ? `${curveItem.color}33` : "rgba(255,255,255,0.05)",
                            color: curveItem.priority === p ? curveItem.color : "#9a9aaa",
                            cursor: "pointer",
                            fontSize: "12px",
                            fontWeight: curveItem.priority === p ? 600 : 400
                          }
                        }, p === 1 ? "High" : p === 2 ? "Med" : "Low")
                      )
                    )
                  ),

                  // Peak Hour Slider (only for Gaussian)
                  curveItem.type === 'gaussian' && e('div', { style: { marginBottom: "16px" } },
                    e('div', { style: { display: "flex", justifyContent: "space-between", marginBottom: "8px" } },
                      e('label', { style: { fontSize: "12px", color: "#9a9aaa" } }, "Peak Hour"),
                      e('span', { style: { fontSize: "14px", fontWeight: 600, color: "#fff" } }, curveItem.peakHour + ":00")
                    ),
                    e('input', { type: "range", min: 0, max: 23, value: curveItem.peakHour, onChange: (ev) => updateCurve(index, {peakHour: Number(ev.target.value)}), style: { background: "linear-gradient(90deg, #ec4899 0%, #be185d 100%)" } })
                  ),

                  // Curve Width Slider (only for Gaussian)
                  curveItem.type === 'gaussian' && e('div', { style: { marginBottom: "16px" } },
                    e('div', { style: { display: "flex", justifyContent: "space-between", marginBottom: "8px" } },
                      e('label', { style: { fontSize: "12px", color: "#9a9aaa" } }, "Curve Width (σ hours)"),
                      e('span', { style: { fontSize: "14px", fontWeight: 600, color: "#fff" } }, curveItem.curveWidth + "h")
                    ),
                    e('input', { type: "range", min: 0.5, max: 6, step: 0.25, value: curveItem.curveWidth, onChange: (ev) => updateCurve(index, {curveWidth: Number(ev.target.value)}), style: { background: "linear-gradient(90deg, #8b5cf6 0%, #6d28d9 100%)" } })
                  ),

                  // Total Demand Slider
                  e('div', { style: { marginBottom: "0" } },
                    e('div', { style: { display: "flex", justifyContent: "space-between", marginBottom: "8px" } },
                      e('label', { style: { fontSize: "12px", color: "#9a9aaa" } }, "Daily Demand"),
                      e('span', { style: { fontSize: "14px", fontWeight: 600, color: "#fff" } }, (curveItem.totalDemand / 1000).toFixed(0) + "k")
                    ),
                    e('input', { type: "range", min: 5000, max: 200000, step: 1000, value: curveItem.totalDemand, onChange: (ev) => updateCurve(index, {totalDemand: Number(ev.target.value)}), style: { background: "linear-gradient(90deg, #10b981 0%, #059669 100%)" } })
                  )
                )
              ),

              // Add Curve Button
              e('button', {
                onClick: addCurve,
                disabled: curves.length >= 3,
                style: {
                  width: "100%",
                  padding: "12px",
                  fontSize: "13px",
                  fontWeight: 500,
                  color: curves.length >= 3 ? "#5a5a6a" : "#818cf8",
                  background: curves.length >= 3 ? "rgba(255,255,255,0.02)" : "rgba(129,140,248,0.1)",
                  border: curves.length >= 3 ? "1px solid rgba(255,255,255,0.06)" : "1px solid rgba(129,140,248,0.2)",
                  borderRadius: "6px",
                  cursor: curves.length >= 3 ? "not-allowed" : "pointer"
                }
              }, curves.length >= 3 ? "Maximum 3 curves" : "+ Add Demand Curve")
            ),

            // Metrics
            e('div', { style: { borderTop: "1px solid rgba(255,255,255,0.06)", paddingTop: "24px" } },
              e('h3', { style: { fontSize: "11px", fontWeight: 500, letterSpacing: "2px", textTransform: "uppercase", color: "#5a5a6a", marginBottom: "20px" } }, "Metrics"),

              e('div', { style: { marginBottom: "20px" } },
                e('div', { style: { fontSize: "11px", color: "#6b6b7b", marginBottom: "4px" } }, "Total Utilization"),
                e('div', { style: { fontSize: "24px", fontWeight: 300, color: "#fff" } },
                  (metrics.totalUtilization / 1000).toFixed(1) + "k",
                  e('span', { style: { fontSize: "13px", color: "#6b6b7b", marginLeft: "6px" } }, "cidu-min")
                )
              ),

              e('div', { style: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: "16px" } },
                e('div', { style: { background: "rgba(249,115,22,0.1)", border: "1px solid rgba(249,115,22,0.2)", borderRadius: "8px", padding: "14px" } },
                  e('div', { style: { fontSize: "10px", color: "#fb923c", marginBottom: "4px", letterSpacing: "1px" } }, "PEAK"),
                  e('div', { style: { fontSize: "20px", fontWeight: 500, color: "#fb923c" } }, metrics.peakUtilization),
                  e('div', { style: { fontSize: "11px", color: "#9a9aaa" } }, metrics.peakPercent + "%")
                ),
                e('div', { style: { background: "rgba(34,197,94,0.1)", border: "1px solid rgba(34,197,94,0.2)", borderRadius: "8px", padding: "14px" } },
                  e('div', { style: { fontSize: "10px", color: "#4ade80", marginBottom: "4px", letterSpacing: "1px" } }, "AVG"),
                  e('div', { style: { fontSize: "20px", fontWeight: 500, color: "#4ade80" } }, metrics.avgUtilization),
                  e('div', { style: { fontSize: "11px", color: "#9a9aaa" } }, metrics.avgPercent + "%")
                )
              ),

              e('div', { style: { background: "rgba(239,68,68,0.1)", border: "1px solid rgba(239,68,68,0.2)", borderRadius: "8px", padding: "14px", marginTop: "16px" } },
                e('div', { style: { fontSize: "10px", color: "#f87171", marginBottom: "4px", letterSpacing: "1px" } }, "SHED"),
                e('div', { style: { fontSize: "20px", fontWeight: 500, color: "#f87171" } }, (metrics.shedDemand / 1000).toFixed(1) + "k"),
                e('div', { style: { fontSize: "11px", color: "#9a9aaa" } }, metrics.shedPercent + "% of demand")
              )
            )
          ),

          // Chart Area
          e('div', { style: { background: "rgba(255,255,255,0.02)", border: "1px solid rgba(255,255,255,0.06)", borderRadius: "12px", padding: "28px" } },
            e('div', { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: "24px" } },
              e('h3', { style: { fontSize: "11px", fontWeight: 500, letterSpacing: "2px", textTransform: "uppercase", color: "#5a5a6a" } }, "24-Hour Demand Profile"),
              e('div', { style: { display: "flex", gap: "16px", fontSize: "11px", flexWrap: "wrap" } },
                e('span', { style: { display: "flex", alignItems: "center", gap: "6px" } },
                  e('span', { style: { width: "12px", height: "8px", background: "linear-gradient(180deg, #6366f1 0%, rgba(99,102,241,0.2) 100%)", display: "inline-block", borderRadius: "2px" } }),
                  e('span', { style: { color: "#9a9aaa" } }, "Actual Utilization")
                ),

                // Per-curve demand legend items
                ...curves.map((curve, index) =>
                  e('span', {
                    key: `legend-${curve.id}`,
                    style: { display: "flex", alignItems: "center", gap: "6px" }
                  },
                    e('span', { style: { width: "12px", height: "2px", background: curve.color, display: "inline-block", opacity: 0.6 } }),
                    e('span', { style: { color: "#9a9aaa" } }, `Curve ${index + 1}`)
                  )
                ),

                e('span', { style: { display: "flex", alignItems: "center", gap: "6px" } },
                  e('span', { style: { width: "12px", height: "2px", background: "#fff", display: "inline-block" } }),
                  e('span', { style: { color: "#9a9aaa" } }, "Capacity")
                ),
                e('span', { style: { display: "flex", alignItems: "center", gap: "6px" } },
                  e('span', { style: { width: "12px", height: "8px", background: "linear-gradient(180deg, #f59e0b 0%, rgba(245,158,11,0.2) 100%)", display: "inline-block", borderRadius: "2px" } }),
                  e('span', { style: { color: "#9a9aaa" } }, "Queue Depth")
                ),
                e('span', { style: { display: "flex", alignItems: "center", gap: "6px" } },
                  e('span', { style: { width: "12px", height: "8px", background: "linear-gradient(180deg, #ef4444 0%, rgba(239,68,68,0.2) 100%)", display: "inline-block", borderRadius: "2px" } }),
                  e('span', { style: { color: "#9a9aaa" } }, "Shed (timeout)")
                )
              )
            ),

            e('div', { style: { height: "400px" } },
              e(ResponsiveContainer, { width: "100%", height: "100%" },
                e(AreaChart, { data: data, margin: { top: 20, right: 30, left: 20, bottom: 20 } },
                  e('defs', null,
                    e('linearGradient', { id: "utilizationGradient", x1: "0", y1: "0", x2: "0", y2: "1" },
                      e('stop', { offset: "0%", stopColor: "#6366f1", stopOpacity: 0.6 }),
                      e('stop', { offset: "100%", stopColor: "#6366f1", stopOpacity: 0.05 })
                    ),
                    e('linearGradient', { id: "queueGradient", x1: "0", y1: "0", x2: "0", y2: "1" },
                      e('stop', { offset: "0%", stopColor: "#f59e0b", stopOpacity: 0.5 }),
                      e('stop', { offset: "100%", stopColor: "#f59e0b", stopOpacity: 0.05 })
                    ),
                    e('linearGradient', { id: "shedGradient", x1: "0", y1: "0", x2: "0", y2: "1" },
                      e('stop', { offset: "0%", stopColor: "#ef4444", stopOpacity: 0.7 }),
                      e('stop', { offset: "100%", stopColor: "#ef4444", stopOpacity: 0.1 })
                    )
                  ),
                  e(XAxis, { dataKey: "time", tick: { fill: "#5a5a6a", fontSize: 10 }, axisLine: { stroke: "#2a2a3a" }, tickLine: { stroke: "#2a2a3a" }, interval: 23 }),
                  e(YAxis, { domain: [0, yMax], tick: { fill: "#5a5a6a", fontSize: 10, fontFamily: "'SF Mono', 'Fira Code', 'Consolas', monospace" }, axisLine: { stroke: "#2a2a3a" }, tickLine: { stroke: "#2a2a3a" }, label: { value: "CIDU", angle: -90, position: "insideLeft", fill: "#5a5a6a", fontSize: 10, dx: -10 }, tickFormatter: (value) => Math.round(value).toString() }),
                  e(Tooltip, { contentStyle: { background: "#1a1a24", border: "1px solid #2a2a3a", borderRadius: "8px", fontSize: "12px" }, labelStyle: { color: "#9a9aaa" }, formatter: (value, name) => {
                    if (name === "actualUtilization") return [value.toFixed(1), "Actual"];
                    if (name === "inputDemand") return [value.toFixed(1), "Input"];
                    if (name === "shedDemand") return [value.toFixed(1), "Shed"];
                    return [value.toFixed(1), name];
                  } }),
                  e(ReferenceLine, { y: machines, stroke: "#ffffff", strokeWidth: 2 }),

                  // Per-curve input demand lines (dashed)
                  ...curves.map(curve =>
                    e(Area, {
                      key: `demand-${curve.id}`,
                      type: "monotone",
                      dataKey: `demand_${curve.id}`,
                      stroke: curve.color,
                      strokeWidth: 1.5,
                      fill: "none",
                      strokeOpacity: 0.6,
                      strokeDasharray: "4 4"
                    })
                  ),

                  // Aggregate input demand line (lighter, for reference)
                  e(Area, { type: "monotone", dataKey: "inputDemand", stroke: "#818cf8", strokeWidth: 1, fill: "none", strokeOpacity: 0.2, strokeDasharray: "2 2" }),
                  e(Area, { type: "monotone", dataKey: "queuedDemand", stroke: "#f59e0b", strokeWidth: 1.5, fill: "url(#queueGradient)" }),
                  e(Area, { type: "monotone", dataKey: "actualUtilization", stroke: "#818cf8", strokeWidth: 2, fill: "url(#utilizationGradient)" }),
                  e(Area, { type: "monotone", dataKey: "shedDemand", stroke: "#ef4444", strokeWidth: 1.5, fill: "url(#shedGradient)" })
                )
              )
            ),

            e('div', { style: { marginTop: "20px", padding: "16px", background: "rgba(99,102,241,0.08)", border: "1px solid rgba(99,102,241,0.15)", borderRadius: "8px", fontSize: "12px", color: "#a5a5b5" } },
              e('strong', { style: { color: "#c4b5fd" } }, "Queueing Model"),
              " — Requests exceeding capacity are queued (amber area, FIFO). Requests waiting longer than " + queueTimeout + " minutes are dropped. " + (metrics.shedDemand / 1000).toFixed(1) + "k cidu-min shed (" + metrics.shedPercent + "% of total demand)."
            )
          )
        )
      );
    }

    const root = createRoot(document.getElementById('root'));
    root.render(e(DemandCapacityViz));
  </script>
</body>
</html>
